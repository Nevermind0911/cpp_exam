- set, multiset, map, multimap
- unordered_set, unordered_map
- внутреннее устройство и основные операции
- итераторы и их инвалидация


Ассоциативные контейнеры:
* Переупорядочивают элементы для быстрого поиска `O(n log n)`
* возможные реализации: дерево поиска

Особенности:
* Требуют отношение порядка: для элементов должен быть определен `operator<()`
* Нет произвольного доступа по индексу

**Методы, которые есть у всех контейнеров:**
1. Конструктор по умолчанию, конструктор копирования, оператор присваивания, деструктор.
2. Операторы сравнения: `==, !=, >, >=, <, <=`.
3. `size()`, `empty()`.
4. `swap()`.
5. `insert()`, `erase()`
6. `clear()`

**Общие методы для Ассоциативных контейнеров**
1. erase по key
2. insert/insert по key
3. `count` - число элементов с заданным `key`
4. `find` поиск на точное совпадение
5. `lower_bound, upper_bound, equal_range` - возвращает итератор на первый элемент не меньше `key`, ..., ...

# set, multiset, map, multimap

**1.** **`set`**
Элементы являются уникальными (дубликат не добавится). Реализуется binary-searching-tree, в вершине key. Порядок не сохраняется (все будет отсортированно). Изменить добавленный элемент нельзя, тк при изменении значения в вершине дерева поиска нарушается порядок.
```cpp
#include <set>

std::set<int> s;
s.insert(10);
s.insert(20);
s.insert(10); // Не добавится, тк 10 уже есть => size() = 2.
```
---
**2.** **`multiset`**
Дубликаты допустимы. Реализуется binary-searching-tree, в вершине key. Порядок не сохраняется (все будет отсортированно). Изменить добавленный элемент нельзя, тк при изменении значения в вершине дерева поиска нарушается порядок.
```cpp
std::multiset<int> ms;
ms.insert(1);
ms.insert(2);
ms.insert(2); // ms.size() == 3
std::cout << ms.count(2) << '\n';
```
---
**3.** **`map`**
Элементы являются уникальными (дубликат не добавится). Реализуется binary-searching-tree, в вершине пара key/value.
```cpp
std::map<string,int> phonebook;
phonebook.insert(std::pair<string, int>("Mary", 2128506));
phonebook.insert(std::make_pair("Alex", 9286385));
phonebook.insert(std::make_pair("Bob", 2128506));
```
---
**4.** **`multimap`**
Дубликаты допустимы. Реализуется binary-searching-tree, в вершине пара key/value.

! В мапе еще есть инвалидация итераторов и ограничения на operator[], это в [презе](https://drive.google.com/file/d/1XOj8Mes6pQTWOuv5UeIZad5V0FhByzRy/view), мне лень писать

# unordered_set, unordered_map

**1.** **`unordered_set`**
Контейнер, хранящий уникальные элементы (ключи) без определенного порядка. Элементы хэшируются, что обеспечивает быстрый доступ.

**2.** **`unordered_map`**
Контейнер, хранящий уникальные пары ключ-значение, где ключи уникальные и хэшируются.

# Внутреннее устройство
Ассоциативные контейнеры:
* Переупорядочивают элементы для быстрого поиска `O(n log n)`
* возможные реализации: дерево поиска

Особенности:
* Требуют отношение порядка: для элементов должен быть определен `operator<()`
* Нет произвольного доступа по индексу

**Методы, которые есть у всех контейнеров:**
1. Конструктор по умолчанию, конструктор копирования, оператор присваивания, деструктор.
2. Операторы сравнения: `==, !=, >, >=, <, <=`.
3. `size()`, `empty()`.
4. `swap()`.
5. `insert()`, `erase()`
6. `clear()`

**Общие методы для Ассоциативных контейнеров**
1. erase по key
2. insert/insert по key
3. `count` - число элементов с заданным `key`
4. `find` поиск на точное совпадение
5. `lower_bound, upper_bound, equal_range` - возвращает итератор на первый элемент не меньше `key`, ..., ...

# Инвалидация
Неправильно:
```cpp
std::map<string, int> m;
std::map<string, int>::iterator it = m.begin();
for( ; it != m.end(); ++it)
if (it->second == 0)
m.erase(it);
```

Правильно:
```cpp
for( ; it != m.end(); )
if (it->second == 0) m.erase(it++);
else ++it;
```
