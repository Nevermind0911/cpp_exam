- string, vector, list, string, string_view
- array
- внутреннее устройство и основные операции
- итераторы и их инвалидация

**Методы, которые есть у всех контейнеров:**
1. Конструктор по умолчанию, конструктор копирования, оператор присваивания, деструктор.
2. Операторы сравнения: `==, !=, >, >=, <, <=`.
3. `size()`, `empty()`.
4. `swap()`.
5. `insert()`, `erase()`
6. `clear()`
7. `begin()`, `end()`

# string, vector, list, string, string_view

**1.** **`std::string`**
Контейнер для хранения символьных последовательностей.
1. Метод `c_str` для совместимости со старым кодом
```cpp
std::string res = "Hello!";
printf("%s", res.c_str());
```
1. Множество алгоритмов по типу `substr()`, `find()`, etc.
2. Поддержка преобразований типа с `C` строками.
```cpp
f(const std::string& s);
f("Hello!");
```
4. `append`, `operator+`, `operator+=`
5. `{c++ icon title:str} string = basic_string<char>` 
6. `{c++ icon title:str} wstring = basic_string<wchar_t>`
---
**2.** **`std::vector`**
Динамический массив с автоматическим изменением размера при добавлении элементов.
1. `size()/resize()` - добавление элементов
2. `capacity()/reserve()` - управление зарезервированной памятью 
3. `push_back()/pop_back()` - добавление/удаление последнего
4. `operator[], at()` - at бросает исключение при выходе за границу
5. `data()` - указатель на массив
---
**3.** **`std::list`**
Двусвязный список. В любом месте контейнера вставка и удаление производятся за `O(1)`. Нет обращения по индексу.
1. `size()/resize()`
2. `push_back()/push_front()`
3. `pop_back()/pop_front()`
4. `merge`, `splice`
---
**4.** **`std::string_view`**
Легковестный, неизменяемый (read-only) класс, предназначенный для работы со строками без владения ими. Буквально показывает уже имеющуюся в памяти строку без необходимости копировать ее.
1. `data()` - возвращает указатель на начало
2. `size()/length()` - возвращает длину
3. `substr(pos, len)` - создает новый `string_view` для подстроки
4. `find()`, `starts_with()`, `ends_with()`.

# Array

Честно, хз, что тут писать

# Внутренне устройство и основные операции

* Корректно работает конструктор копий.
* Корректно работает оператор присваивания.
**Методы, которые есть у всех контейнеров:**
1. Конструктор по умолчанию, конструктор копирования, оператор присваивания, деструктор.
2. Операторы сравнения: `==, !=, >, >=, <, <=`.
3. `size()`, `empty()`.
4. `swap()`.
5. `insert()`, `erase()`
6. `clear()`
7. `begin()`, `end()`

# Итераторы и их инвалидация

Итератор это:
* Объект, который синтаксически ведет себя как указатель (определены ++, -, *. ->).
* Универсальный способ перебора элементов контейнеров в STL 
* Реализованы как вложенные классы для контейнеров
```cpp
class vector {
	class iterator {
		T* ptr;
		operator++() { ptr++; }
	} 
}
vector::iterator it1;
```

Все контейнеры имеют функции, которые возвращают итераторы на первый элемент и на элемент, следующий за последним.
```cpp
vector<int> v;
vector<int>::iterator begin = v.begin();
vector<int>::iterator end = v.end();
```
---
Инвалидация: (итератор перестает указывать в нужное место)
С контейнером произвели операцию и теперь итераторы указывают в неверное место.
```cpp
vector<int> v;
it = v.erase(it);
vector<int>::iterator itb = v.begin();
v.push_back(3);
...
v.push_back(5);
```
Чтобы понять, происходит ли инвалидация, нужно знать внутреннее устройство контейнера.
